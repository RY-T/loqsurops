#from genome index align lib

#snakemake --dag | dot -Tsvg > dag.svg
import os
lib_list=[]
bt_prefix_list=[]


rule all:
	input:'Seq_map_directory'		

rule sequential_mapping:
	output: 'Seq_map_directory'
	run:
		import os
		os.mkdir('Seq_map_directory')
		fasta_folder='modified_bed/fasta/bt_indexes'
		for file in os.listdir(os.path.join(os.getcwd(),fasta_folder)):
			if file.endswith(".rev.1.ebwt"):
				bt_prefix_list.append(file[:-11]) 
		bt_prefix_list.sort()
#needs better sort function key=fn
		RNA_Lib_fastq_folder='RNA_LIB'
		for file in os.listdir(os.path.join(os.getcwd(),RNA_Lib_fastq_folder)):
			if file.endswith(".fastq"):
				lib_list.append(file[:-6]) 
		for j in range(len(lib_list)):
			LIB=lib_list[j]
			short_reads=os.path.join(RNA_Lib_fastq_folder,'02preprocessouput/'+LIB+'_final_col_filter.fasta')
			for i in range(len(bt_prefix_list)):
				Index=bt_prefix_list[i]
				Previously_unmapped=bt_prefix_list[i-1]
				if i ==0:
					shell('bowtie -f --un Seq_map_directory/{LIB}_unmapped_{Index}.fasta -a -v 0 -p 1 -t modified_bed/fasta/bt_indexes/{Index} {short_reads} > Seq_map_directory/{LIB}_mapped{Index}.bowtie.txt')
				else:
					shell('bowtie -f --un Seq_map_directory/{LIB}_unmapped_{Index}.fasta -a -v 0 -p 1 -t modified_bed/fasta/bt_indexes/{Index} Seq_map_directory/{LIB}_unmapped_{Previously_unmapped}.fasta > Seq_map_directory/{LIB}_mapped{Index}.bowtie.txt')



#bowtie -f --un ${LIB}unmapcol${INDEXBASE}.fasta -a -v 0 -p 1 -t ${MAPINDEX} ${INPUTMAPFASTAFILE} \
#> ${LIB}mapcol${INDEXBASE}.bowtie.txt

#bowtie -f --un ${LIB}unmapcol${INDEX1}.fasta -a -v 0 -p ${NSLOTS} -t ${INDEX1} ${LIB}mapcol${INDEXBASE}.fasta \
#> ${LIB}mapcol${INDEX1}.bowtie.txt

#rule last_index_mapping

#rule counts:


###
'''
{lib} 

LIB=$1
MINLENGTH=$2  #18
MAXLENGTH=$3  #30
MAPINDEX=$4   #dme3excludeUextra
INDEXBASE=$5  #dm3excludeUext
NTMISMATCH=$6 #0
ALIGNREPORT=$7 #a
FXARTIFACTFILTER=$8 #fxaf

NSLOTS=1

INPUTMAPFASTAFILE=/data/OkamuraLab/processedlibraries/clip${LENGTHFILTERFASTA}${FXARTIFACTFILTER}colidfasta/${LIB}clip${LENGTHFILTERFASTA}${FXARTIFACTFILTER}colid.fasta


bowtie -f --un ${LIB}unmapcol${INDEXBASE}.fasta -a -v 0 -p 1 -t ${MAPINDEX} ${INPUTMAPFASTAFILE} \
> ${LIB}mapcol${INDEXBASE}.bowtie.txt




echo "count how many reads were mapped for ${LIB}mapcol${INDEXBASE}.bowtie.txt"
MAPGENOME=$(awk '{OFS=FS="\t"} {a[$1]++} END {for (b in a) {print b}}' ${LIB}mapcol${INDEXBASE}.bowtie.txt | \
awk 'BEGIN {FS="_"; OFS="\t"} {print $1,$2,$3}' | awk '{SUM+=$3} END {if (SUM > 0) print SUM; else print "0"}')

echo $MAPGENOME

echo "count how many unmapped reads in ${LIB}unmapcol${INDEXBASE}.fasta"
UNMAPGENOME=$(fasta_formatter -i ${LIB}unmapcol${INDEXBASE}.fasta -t | \
awk 'BEGIN {FS="_"; OFS="\t"} {print $1,$2,$3}' | awk '{SUM+=$3} END {if (SUM > 0) print SUM; else print "0"}')

echo $UNMAPGENOME

echo "sum of map and unmap reads"
SUMREADGENOME=$(($MAPGENOME+$UNMAPGENOME))
echo $SUMREADGENOME

echo "percentage of mapped reads with ${NTMISMATCH} mismatches"
PERGENOME=$(awk 'BEGIN {printf ("%0.2f", '$MAPGENOME' / '$SUMREADGENOME' * 100)}')
echo $PERGENOME


awk 'BEGIN {OFS=FS="\t"} {print $1,$2,$3,$4,$5,$6,$7+1}' ${LIB}mapcol${INDEXBASE}.bowtie.txt > ${LIB}temp01.txt
sort -k1,1 ${LIB}temp01.txt > ${LIB}temp1.txt

echo "list uniques for fastaCollapseID and strand by removing duplicates, leaving top row"
awk '!x[$1,$2]++' ${LIB}temp1.txt > ${LIB}temp2.txt

echo "sum alignmentColumn+1 if have same fastaCollapseID"
awk '{OFS=FS="\t"} {a[$1]+=$7} END {for (i in a) print i,a[i]}' ${LIB}temp2.txt > ${LIB}temp02.txt
sort -k1,1 ${LIB}temp02.txt > ${LIB}temp3.txt  #This is the correct genomic hits count.

echo "convert mapping fasta file to tab format"
fasta_formatter -i ${INPUTMAPFASTAFILE} -t > ${LIB}temp03.txt
sort -k1,1 ${LIB}temp03.txt > ${LIB}clip${LENGTHFILTERFASTA}${FXARTIFACTFILTER}colidtab.txt

echo "do join to match mapped id with mapping fasta file"
join ${LIB}temp3.txt ${LIB}clip${LENGTHFILTERFASTA}${FXARTIFACTFILTER}colidtab.txt > ${LIB}temp4.txt

echo "do join to match bowtie standard output alignment+1"
join ${LIB}temp4.txt ${LIB}temp1.txt > ${LIB}mapcol${INDEXBASE}.bowtie.fix.txt

echo "head check ${LIB}mapcol${INDEXBASE}.bowtie.fix.txt"
head ${LIB}mapcol${INDEXBASE}.bowtie.fix.txt


# Count unique and multiple mappers
echo "separate lists into multiple mappers and unique mappers"
awk '$2 == 1' ${LIB}mapcol${INDEXBASE}.bowtie.fix.txt > uniqmap${LIB}mapcol${INDEXBASE}.bowtie.fix.txt
awk '$2 > 1' ${LIB}mapcol${INDEXBASE}.bowtie.fix.txt > multimap${LIB}mapcol${INDEXBASE}.bowtie.fix.txt

echo "count reads that are unique mappers"
UNIMAP=$(awk '!x[$1]++' uniqmap${LIB}mapcol${INDEXBASE}.bowtie.fix.txt | \
awk 'BEGIN {OFS="\t"; FS="_| "} {print $3}' | \
awk '{SUM+=$1} END {if (SUM > 0) print SUM; else print "0"}')

echo $UNIMAP

echo "count reads that are multiple mappers"
MULMAP=$(awk '!x[$1]++' multimap${LIB}mapcol${INDEXBASE}.bowtie.fix.txt | \
awk 'BEGIN {OFS="\t"; FS="_| "} {print $3}' | \
awk '{SUM+=$1} END {if (SUM > 0) print SUM; else print "0"}')

echo $MULMAP

echo "count sum of unique and multiple mappers"
SUMREADMAPPERS=$(($UNIMAP+$MULMAP))

echo $SUMREADMAPPERS

echo "complete list"
echo $UNIMAP
echo $MULMAP
echo $SUMREADMAPPERS


# convert bowtie fix file to fasta for remapping
echo "print fastaCollapseID and sequence"
echo "list uniques for fastaCollapseID removing duplicates, leaving top row"
awk 'BEGIN {OFS="\t"; FS=" "} {print $1,$3}' ${LIB}mapcol${INDEXBASE}.bowtie.fix.txt | \
awk '!x[$1,$2]++' > ${LIB}mapcol${INDEXBASE}.tab

echo "head check ${LIB}mapcol${INDEXBASE}.tab"
head ${LIB}mapcol${INDEXBASE}.tab
wc -l ${LIB}mapcol${INDEXBASE}.tab

echo "convert to fasta"
awk '{print ">"$1"\n"$2}' ${LIB}mapcol${INDEXBASE}.tab > ${LIB}mapcol${INDEXBASE}.fasta

echo "head check ${LIB}mapcol${INDEXBASE}.fasta"
head ${LIB}mapcol${INDEXBASE}.fasta
wc -l ${LIB}mapcol${INDEXBASE}.fasta


# library statistics mapping with perfect matches, all alignments reported
echo "use reads that match perfectly to ${INDEXBASE}"
echo "head check ${LIB}mapcol${INDEXBASE}.fasta"
head ${LIB}mapcol${INDEXBASE}.fasta

echo " STEP 1 background RNAs"

echo "running bowtie, ${INDEX1} index, fasta input, \
report perfect match, all alignments, bowtie output format"
bowtie -f --un ${LIB}unmapcol${INDEX1}.fasta -a -v 0 -p ${NSLOTS} -t ${INDEX1} ${LIB}mapcol${INDEXBASE}.fasta \
> ${LIB}mapcol${INDEX1}.bowtie.txt

echo "done with mapping"

echo "head check ${LIB}mapcol${INDEX1}.bowtie.txt"
head ${LIB}mapcol${INDEX1}.bowtie.txt

echo "count how many reads were mapped for ${LIB}mapcol${INDEX1}.bowtie.txt"
MAP1=$(awk '{OFS=FS="\t"} {a[$1]++} END {for (b in a) {print b}}' ${LIB}mapcol${INDEX1}.bowtie.txt | \
awk 'BEGIN {FS="_"; OFS="\t"} {print $1,$2,$3}' | awk '{SUM+=$3} END {if (SUM > 0) print SUM; else print "0"}')

echo $MAP1


echo "running bowtie, ${INDEX2} index, fasta input from previous unmatched, \
report perfect match, all alignments, bowtie output format"
bowtie -f --un ${LIB}unmapcol${INDEX2}.fasta -a -v 0 -p ${NSLOTS} -t ${INDEX2} ${LIB}unmapcol${INDEX1}.fasta \
> ${LIB}mapcol${INDEX2}.bowtie.txt

# Remap the unmapped reads after INDEX30 to dm3excludeUext to find unique and multiple mappers

echo "running bowtie, ${MAPINDEX} index, fasta input from previous unmatched, \
report perfect match, all alignments, bowtie output format"
bowtie -f --un ${LIB}unmapcol${INDEX31}.fasta -a -v 0 -p ${NSLOTS} -t ${MAPINDEX} ${LIB}unmapcol${INDEX30}.fasta \
> ${LIB}mapcol${INDEX31}.bowtie.txt

echo "done with mapping"

echo "head check ${LIB}mapcol${INDEX31}.bowtie.txt"
head ${LIB}mapcol${INDEX31}.bowtie.txt

echo "count how many reads were mapped for ${LIB}mapcol${INDEX31}.bowtie.txt"
MAP31=$(awk '{OFS=FS="\t"} {a[$1]++} END {for (b in a) {print b}}' ${LIB}mapcol${INDEX31}.bowtie.txt | \
awk 'BEGIN {FS="_"; OFS="\t"} {print $1,$2,$3}' | awk '{SUM+=$3} END {if (SUM > 0) print SUM; else print "0"}')

echo $MAP31

echo "count how many unmapped reads in ${LIB}unmapcol${INDEX31}.fasta"
UNMAP31=$(fasta_formatter -i ${LIB}unmapcol${INDEX31}.fasta -t | \
awk 'BEGIN {FS="_"; OFS="\t"} {print $1,$2,$3}' | awk '{SUM+=$3} END {if (SUM > 0) print SUM; else print "0"}')

echo $UNMAP31



# Fix bowtie mapping file
echo "append fastaCollapseID to strand orientation"
echo "add 1 to the alignment column in bowtie standard output format"
echo "do regular sort on first column"

awk 'BEGIN {OFS=FS="\t"} {print $1,$2,$3,$4,$5,$6,$7+1}' ${LIB}mapcol${INDEX31}.bowtie.txt > ${LIB}${INDEX31}temp01.txt
sort -k1,1 ${LIB}${INDEX31}temp01.txt > ${LIB}${INDEX31}temp1.txt

echo "list uniques for fastaCollapseID and strand by removing duplicates, leaving top row"
awk '!x[$1,$2]++' ${LIB}${INDEX31}temp1.txt > ${LIB}${INDEX31}temp2.txt

echo "sum alignmentColumn+1 if have same fastaCollapseID"
awk '{OFS=FS="\t"} {a[$1]+=$7} END {for (i in a) print i,a[i]}' ${LIB}${INDEX31}temp2.txt > ${LIB}${INDEX31}temp02.txt
sort -k1,1 ${LIB}${INDEX31}temp02.txt > ${LIB}${INDEX31}temp3.txt  #This is the correct genomic hits count.

echo "convert mapping fasta file to tab format"
fasta_formatter -i ${LIB}unmapcol${INDEX30}.fasta -t > ${LIB}${INDEX31}temp03.txt
sort -k1,1 ${LIB}${INDEX31}temp03.txt > ${LIB}${INDEX31}clip${LENGTHFILTERFASTA}${FXARTIFACTFILTER}colidtab.txt

echo "do join to match mapped id with mapping fasta file"
join ${LIB}${INDEX31}temp3.txt ${LIB}${INDEX31}clip${LENGTHFILTERFASTA}${FXARTIFACTFILTER}colidtab.txt > ${LIB}${INDEX31}temp4.txt

echo "do join to match bowtie standard output alignment+1"
join ${LIB}${INDEX31}temp4.txt ${LIB}${INDEX31}temp1.txt > ${LIB}mapcol${INDEX31}.bowtie.fix.txt

echo "head check ${LIB}mapcol${INDEX31}.bowtie.fix.txt"
head ${LIB}mapcol${INDEX31}.bowtie.fix.txt


# Count unique and multiple mappers
echo "separate lists into multiple mappers and unique mappers"
awk '$2 == 1' ${LIB}mapcol${INDEX31}.bowtie.fix.txt > uniqmap${LIB}mapcol${INDEX31}.bowtie.fix.txt
awk '$2 > 1' ${LIB}mapcol${INDEX31}.bowtie.fix.txt > multimap${LIB}mapcol${INDEX31}.bowtie.fix.txt

echo "count reads that are unique mappers"
UNIMAPREMAP=$(awk '!x[$1]++' uniqmap${LIB}mapcol${INDEX31}.bowtie.fix.txt | \
awk 'BEGIN {OFS="\t"; FS="_| "} {print $3}' | \
awk '{SUM+=$1} END {if (SUM > 0) print SUM; else print "0"}')

echo $UNIMAPREMAP

echo "count reads that are multiple mappers"
MULMAPREMAP=$(awk '!x[$1]++' multimap${LIB}mapcol${INDEX31}.bowtie.fix.txt | \
awk 'BEGIN {OFS="\t"; FS="_| "} {print $3}' | \
awk '{SUM+=$1} END {if (SUM > 0) print SUM; else print "0"}')

echo $MULMAPREMAP

echo "count sum of unique and multiple mappers"
SUMREADMAPREMAPPERS=$(($UNIMAPREMAP+$MULMAPREMAP))

echo $SUMREADMAPREMAPPERS

echo "complete list"
echo $UNIMAPREMAP
echo $MULMAPREMAP
echo $SUMREADMAPREMAPPERS
'''